!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE")):t.ENABLE3D=e(t.THREE)}(window,(function(t){return function(t){var e={};function o(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,o),i.l=!0,i.exports}return o.m=t,o.c=e,o.d=function(t,e,s){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(o.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)o.d(s,i,function(e){return t[e]}.bind(null,i));return s},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=16)}([function(e,o){e.exports=t},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=t=>{console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55")}},function(t,e,o){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedMesh=void 0;const s=o(0);class i extends s.Mesh{constructor(t,e){super(t,e),this.vector3=new s.Vector3,this.isGroup=!1,this.hasBody=!1,this.name="object-"+this.id}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}e.ExtendedMesh=i},function(t,e,o){"use strict";var s=Object.prototype.hasOwnProperty,i="~";function n(){}function r(t,e,o){this.fn=t,this.context=e,this.once=o||!1}function a(t,e,o,s,n){if("function"!=typeof o)throw new TypeError("The listener must be a function");var a=new r(o,s||t,n),l=i?i+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],a]:t._events[l].push(a):(t._events[l]=a,t._eventsCount++),t}function l(t,e){0==--t._eventsCount?t._events=new n:delete t._events[e]}function c(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(i=!1)),c.prototype.eventNames=function(){var t,e,o=[];if(0===this._eventsCount)return o;for(e in t=this._events)s.call(t,e)&&o.push(i?e.slice(1):e);return Object.getOwnPropertySymbols?o.concat(Object.getOwnPropertySymbols(t)):o},c.prototype.listeners=function(t){var e=i?i+t:t,o=this._events[e];if(!o)return[];if(o.fn)return[o.fn];for(var s=0,n=o.length,r=new Array(n);s<n;s++)r[s]=o[s].fn;return r},c.prototype.listenerCount=function(t){var e=i?i+t:t,o=this._events[e];return o?o.fn?1:o.length:0},c.prototype.emit=function(t,e,o,s,n,r){var a=i?i+t:t;if(!this._events[a])return!1;var l,c,m=this._events[a],h=arguments.length;if(m.fn){switch(m.once&&this.removeListener(t,m.fn,void 0,!0),h){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,e),!0;case 3:return m.fn.call(m.context,e,o),!0;case 4:return m.fn.call(m.context,e,o,s),!0;case 5:return m.fn.call(m.context,e,o,s,n),!0;case 6:return m.fn.call(m.context,e,o,s,n,r),!0}for(c=1,l=new Array(h-1);c<h;c++)l[c-1]=arguments[c];m.fn.apply(m.context,l)}else{var d,u=m.length;for(c=0;c<u;c++)switch(m[c].once&&this.removeListener(t,m[c].fn,void 0,!0),h){case 1:m[c].fn.call(m[c].context);break;case 2:m[c].fn.call(m[c].context,e);break;case 3:m[c].fn.call(m[c].context,e,o);break;case 4:m[c].fn.call(m[c].context,e,o,s);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];m[c].fn.apply(m[c].context,l)}}return!0},c.prototype.on=function(t,e,o){return a(this,t,e,o,!1)},c.prototype.once=function(t,e,o){return a(this,t,e,o,!0)},c.prototype.removeListener=function(t,e,o,s){var n=i?i+t:t;if(!this._events[n])return this;if(!e)return l(this,n),this;var r=this._events[n];if(r.fn)r.fn!==e||s&&!r.once||o&&r.context!==o||l(this,n);else{for(var a=0,c=[],m=r.length;a<m;a++)(r[a].fn!==e||s&&!r[a].once||o&&r[a].context!==o)&&c.push(r[a]);c.length?this._events[n]=1===c.length?c[0]:c:l(this,n)}return this},c.prototype.removeAllListeners=function(t){var e;return t?(e=i?i+t:t,this._events[e]&&l(this,e)):(this._events=new n,this._eventsCount=0),this},c.prototype.off=c.prototype.removeListener,c.prototype.addListener=c.prototype.on,c.prefixed=i,c.EventEmitter=c,t.exports=c},function(t,e,o){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedObject3D=void 0;const s=o(0);class i extends s.Object3D{constructor(){super(),this.vector3=new s.Vector3,this.isGroup=!1,this.hasBody=!1,this.anims={},this._currentAnimation="",this._animationActions=new Map,this.name="object-"+this.id}setAction(t){console.warn("[enable3d] setAction(name) is deprecated. Use animation.play(name) instead!"),this.animationPlay(t)}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}get animation(){return{current:this._currentAnimation,add:(t,e)=>this.animationAdd(t,e),play:(t,e=500,o=!0)=>this.animationPlay(t,e,o),mixer:this.animationMixer}}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new s.AnimationMixer(this)),this._animationMixer}animationAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}animationPlay(t,e=500,o=!0){const i=this._animationActions.get(t),n=this._animationActions.get(this._currentAnimation);i&&(i.reset(),n&&(i.crossFadeFrom(n,e/1e3,!0),i.clampWhenFinished=!0),o||i.setLoop(s.LoopOnce,0),i.play()),this._currentAnimation=t}}e.ExtendedObject3D=i,e.default=i},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const s=o(0);e.default=class{constructor(){this._defaultMaterial=new s.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=(t,e)=>{e.forEach(e=>{Object.getOwnPropertyNames(e.prototype).forEach(o=>{Object.defineProperty(t.prototype,o,Object.getOwnPropertyDescriptor(e.prototype,o))})})}},function(t,e,o){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedGroup=void 0;const s=o(0);class i extends s.Group{constructor(){super(),this.isMesh=!1,this.hasBody=!1,this.name="object-"+this.id}}e.ExtendedGroup=i},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.PhysicsLoader=void 0;const s=o(15);e.PhysicsLoader=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),s.default(t,()=>{Ammo().then(()=>{e()})})}},function(t,e,o){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0}),e.Group=e.Points=e.Line=e.Material=e.Mesh=e.Object3D=e.AnimationAction=e.AnimationClip=e.AnimationMixer=e.ExtendedMesh=e.ExtendedObject3D=void 0;const s=o(4);Object.defineProperty(e,"ExtendedObject3D",{enumerable:!0,get:function(){return s.ExtendedObject3D}});const i=o(2);Object.defineProperty(e,"ExtendedMesh",{enumerable:!0,get:function(){return i.ExtendedMesh}});var n=o(0);Object.defineProperty(e,"AnimationMixer",{enumerable:!0,get:function(){return n.AnimationMixer}}),Object.defineProperty(e,"AnimationClip",{enumerable:!0,get:function(){return n.AnimationClip}}),Object.defineProperty(e,"AnimationAction",{enumerable:!0,get:function(){return n.AnimationAction}}),Object.defineProperty(e,"Object3D",{enumerable:!0,get:function(){return n.Object3D}}),Object.defineProperty(e,"Mesh",{enumerable:!0,get:function(){return n.Mesh}}),Object.defineProperty(e,"Material",{enumerable:!0,get:function(){return n.Material}}),Object.defineProperty(e,"Line",{enumerable:!0,get:function(){return n.Line}}),Object.defineProperty(e,"Points",{enumerable:!0,get:function(){return n.Points}}),Object.defineProperty(e,"Group",{enumerable:!0,get:function(){return n.Group}})},function(t,e,o){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(e,"__esModule",{value:!0});const s=o(14),i=o(0);e.default=class{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new i.Euler,this.tmpQuaternion=new i.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new s.EventEmitter,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new s.EventEmitter)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",()=>{t()}):this.eventEmitter.on("update",()=>{t()})}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",e=>{const{bodies:o,event:s}=e;o[0].name===this.name?t(o[1],s):o[1].name===this.name&&t(o[0],s)})}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,o){const s=this.tmpEuler.set(t,e,o),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(s),this.tmpBtQuaternion.setValue(0,0,0,1);const n=this.tmpBtQuaternion;n.setValue(i.x,i.y,i.z,i.w);this.physics.worldTransform.setRotation(n)}get rotation(){let t,e,o;const s=this.physics.worldTransform.getRotation();let i=this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w());i.w>1&&(i=i.normalize());const n=2*Math.acos(i.w),r=Math.sqrt(1-i.w*i.w);return r<.001?(t=i.x,e=i.y,o=i.z):(t=i.x/r,e=i.y/r,o=i.z/r),{x:t*n,y:e*n,z:o*n}}setPosition(t,e,o){this.physics.worldTransform.getOrigin().setValue(t,e,o)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setGravity(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}},function(t,e,o){"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */var s=this&&this.__rest||function(t,e){var o={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(o[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(s=Object.getOwnPropertySymbols(t);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(t,s[i])&&(o[s[i]]=t[s[i]])}return o};Object.defineProperty(e,"__esModule",{value:!0});const i=o(0),n=o(2),r=o(1),a=o(5);e.default=class{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new a.default}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,o){const{x:s=0,y:r=0,z:a=0}=o;let l;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":l=new i.Line(t,e);break;case"PointsMaterial":l=new i.Points(t,e);break;default:l=new n.ExtendedMesh(t,e)}return l.position.set(s,r,a),l.castShadow=l.receiveShadow=!0,l}makeExtrude(t,e){const{x:o,y:n,z:r,name:a,shape:l,autoCenter:c=!0,breakable:m=!1,bufferGeometry:h=!0}=t,d=s(t,["x","y","z","name","shape","autoCenter","breakable","bufferGeometry"]),{depth:u=1,bevelEnabled:p=!1}=d,y=h||m||this.isHeadless?new i.ExtrudeBufferGeometry(l,Object.assign({depth:u,bevelEnabled:p},d)):new i.ExtrudeGeometry(l,Object.assign({depth:u,bevelEnabled:p},d)),f=this.addMaterial(e),b=this.createMesh(y,f,{x:o,y:n,z:r});return c&&b.geometry.center(),b.name=a||"body_id_"+b.id,b.shape="extrude",b}addExtrude(t,e={}){const o=this.makeExtrude(t,e);return this.addExisting(o),o}makePlane(t,e){const{x:o,y:n,z:r,name:a,breakable:l=!1,bufferGeometry:c=!0}=t,m=s(t,["x","y","z","name","breakable","bufferGeometry"]),h=c||l||this.isHeadless?new i.PlaneBufferGeometry(m.width||1,m.height||1,m.widthSegments||1,m.heightSegments||1):new i.PlaneGeometry(m.width||1,m.height||1,m.widthSegments||1,m.heightSegments||1),d=this.addMaterial(e);d.side=i.DoubleSide;const u=this.createMesh(h,d,{x:o,y:n,z:r});return u.name=a||"body_id_"+u.id,u.shape="plane",u}addPlane(t,e){const o=this.makePlane(t,e);return this.addExisting(o),o}makeSphere(t,e){const{x:o,y:n,z:r,name:a,breakable:l=!1,bufferGeometry:c=!0}=t,m=s(t,["x","y","z","name","breakable","bufferGeometry"]),h=c||l||this.isHeadless?new i.SphereBufferGeometry(m.radius||1,m.widthSegments||16,m.heightSegments||12,m.phiStart||void 0,m.phiLength||void 0,m.thetaStart||void 0,m.thetaLength||void 0):new i.SphereGeometry(m.radius||1,m.widthSegments||16,m.heightSegments||12,m.phiStart||void 0,m.phiLength||void 0,m.thetaStart||void 0,m.thetaLength||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:o,y:n,z:r});return u.name=a||"body_id_"+u.id,u.shape="sphere",u}addSphere(t={},e={}){const o=this.makeSphere(t,e);return this.addExisting(o),o}makeBox(t,e){const{x:o,y:n,z:r,name:a,breakable:l=!1,bufferGeometry:c=!0}=t,m=s(t,["x","y","z","name","breakable","bufferGeometry"]),h=c||l||this.isHeadless?new i.BoxBufferGeometry(m.width||1,m.height||1,m.depth||1,m.widthSegments||void 0,m.heightSegments||void 0,m.depthSegments||void 0):new i.BoxGeometry(m.width||1,m.height||1,m.depth||1,m.widthSegments||void 0,m.heightSegments||void 0,m.depthSegments||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:o,y:n,z:r});return u.name=a||"body_id_"+u.id,u.shape="box",u}addBox(t={},e={}){const o=this.makeBox(t,e);return this.addExisting(o),o}addGround(t,e={}){const o=this.makeBox(t,e);return o.rotateX(i.MathUtils.degToRad(90)),this.addExisting(o),o}makeCylinder(t={},e={}){const{x:o,y:n,z:r,name:a,breakable:l=!1,bufferGeometry:c=!0}=t,m=s(t,["x","y","z","name","breakable","bufferGeometry"]),h=c||l||this.isHeadless?new i.CylinderBufferGeometry(m.radiusTop||1,m.radiusBottom||1,m.height||1,m.radiusSegments||void 0,m.heightSegments||void 0,m.openEnded||void 0,m.thetaStart||void 0,m.thetaLength||void 0):new i.CylinderGeometry(m.radiusTop||1,m.radiusBottom||1,m.height||1,m.radiusSegments||void 0,m.heightSegments||void 0,m.openEnded||void 0,m.thetaStart||void 0,m.thetaLength||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:o,y:n,z:r});return u.name=a||"body_id_"+u.id,u.shape="cylinder",u}addCylinder(t={},e={}){const o=this.makeCylinder(t,e);return this.addExisting(o),o}makeCone(t={},e={}){const{x:o,y:n,z:r,name:a,breakable:l=!1,bufferGeometry:c=!0}=t,m=s(t,["x","y","z","name","breakable","bufferGeometry"]),h=(c||l||this.isHeadless,new i.ConeBufferGeometry(m.radius||1,m.height||1,m.radiusSegments||8,m.heightSegments||1,m.openEnded||!1,m.thetaStart||0,m.thetaLength||2*Math.PI)),d=this.addMaterial(e),u=this.createMesh(h,d,{x:o,y:n,z:r});return u.name=a||"body_id_"+u.id,u.shape="cone",u}addCone(t={},e={}){const o=this.makeCone(t,e);return this.addExisting(o),o}makeTorus(t={},e={}){const{x:o,y:n,z:r,name:a,breakable:l=!1,bufferGeometry:c=!0}=t,m=s(t,["x","y","z","name","breakable","bufferGeometry"]),h=c||l||this.isHeadless?new i.TorusBufferGeometry(m.radius||void 0,m.tube||void 0,m.radialSegments||void 0,m.tubularSegments||void 0,m.arc||void 0):new i.TorusGeometry(m.radius||void 0,m.tube||void 0,m.radialSegments||void 0,m.tubularSegments||void 0,m.arc||void 0),d=this.addMaterial(e),u=this.createMesh(h,d,{x:o,y:n,z:r});return u.name=a||"body_id_"+u.id,u.shape="torus",u}addTorus(t={},e={}){const o=this.makeTorus(t,e);return this.addExisting(o),o}addMaterial(t={}){const e=Object.keys(t)[0];let o;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":o=new i.MeshBasicMaterial(t.basic);break;case"normal":o=new i.MeshNormalMaterial(t.normal);break;case"standard":o=new i.MeshStandardMaterial(t.standard);break;case"lambert":o=new i.MeshLambertMaterial(t.lambert);break;case"phong":o=new i.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?o=new i.MeshPhysicalMaterial(t.physical):(r.default("You need to pass parameters to the physical material. (Fallback to default material)"),o=this.defaultMaterial.get());break;case"toon":o=new i.MeshToonMaterial(t.toon);break;case"line":o=new i.LineBasicMaterial(t.line);break;case"points":o=new i.PointsMaterial(t.points);break;case"custom":o=t.custom||this.defaultMaterial.get();break;default:o=this.defaultMaterial.get()}return o}}},function(t,e,o){},function(t,e,o){},function(t,e,o){"use strict";var s=Object.prototype.hasOwnProperty,i="~";function n(){}function r(t,e,o){this.fn=t,this.context=e,this.once=o||!1}function a(t,e,o,s,n){if("function"!=typeof o)throw new TypeError("The listener must be a function");var a=new r(o,s||t,n),l=i?i+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],a]:t._events[l].push(a):(t._events[l]=a,t._eventsCount++),t}function l(t,e){0==--t._eventsCount?t._events=new n:delete t._events[e]}function c(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(i=!1)),c.prototype.eventNames=function(){var t,e,o=[];if(0===this._eventsCount)return o;for(e in t=this._events)s.call(t,e)&&o.push(i?e.slice(1):e);return Object.getOwnPropertySymbols?o.concat(Object.getOwnPropertySymbols(t)):o},c.prototype.listeners=function(t){var e=i?i+t:t,o=this._events[e];if(!o)return[];if(o.fn)return[o.fn];for(var s=0,n=o.length,r=new Array(n);s<n;s++)r[s]=o[s].fn;return r},c.prototype.listenerCount=function(t){var e=i?i+t:t,o=this._events[e];return o?o.fn?1:o.length:0},c.prototype.emit=function(t,e,o,s,n,r){var a=i?i+t:t;if(!this._events[a])return!1;var l,c,m=this._events[a],h=arguments.length;if(m.fn){switch(m.once&&this.removeListener(t,m.fn,void 0,!0),h){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,e),!0;case 3:return m.fn.call(m.context,e,o),!0;case 4:return m.fn.call(m.context,e,o,s),!0;case 5:return m.fn.call(m.context,e,o,s,n),!0;case 6:return m.fn.call(m.context,e,o,s,n,r),!0}for(c=1,l=new Array(h-1);c<h;c++)l[c-1]=arguments[c];m.fn.apply(m.context,l)}else{var d,u=m.length;for(c=0;c<u;c++)switch(m[c].once&&this.removeListener(t,m[c].fn,void 0,!0),h){case 1:m[c].fn.call(m[c].context);break;case 2:m[c].fn.call(m[c].context,e);break;case 3:m[c].fn.call(m[c].context,e,o);break;case 4:m[c].fn.call(m[c].context,e,o,s);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];m[c].fn.apply(m[c].context,l)}}return!0},c.prototype.on=function(t,e,o){return a(this,t,e,o,!1)},c.prototype.once=function(t,e,o){return a(this,t,e,o,!0)},c.prototype.removeListener=function(t,e,o,s){var n=i?i+t:t;if(!this._events[n])return this;if(!e)return l(this,n),this;var r=this._events[n];if(r.fn)r.fn!==e||s&&!r.once||o&&r.context!==o||l(this,n);else{for(var a=0,c=[],m=r.length;a<m;a++)(r[a].fn!==e||s&&!r[a].once||o&&r[a].context!==o)&&c.push(r[a]);c.length?this._events[n]=1===c.length?c[0]:c:l(this,n)}return this},c.prototype.removeAllListeners=function(t){var e;return t?(e=i?i+t:t,this._events[e]&&l(this,e)):(this._events=new n,this._eventsCount=0),this},c.prototype.off=c.prototype.removeListener,c.prototype.addListener=c.prototype.on,c.prefixed=i,c.EventEmitter=c,t.exports=c},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const s=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){}return!1})(),i=(t,e)=>{var o=document.createElement("script");o.onload=()=>{e()},o.onerror=()=>{throw new Error("failed to load "+t)},o.async=!0,o.src=t,document.head.appendChild(o)};e.default=(t,e)=>{i(s?t+"/ammo.wasm.js":t+"/ammo.js",()=>e())}},function(t,e,o){"use strict";o.r(e),o.d(e,"ExtendedObject3D",(function(){return a.ExtendedObject3D})),o.d(e,"ExtendedMesh",(function(){return l.ExtendedMesh})),o.d(e,"ExtendedGroup",(function(){return c.ExtendedGroup})),o.d(e,"PhysicsLoader",(function(){return R.PhysicsLoader})),o.d(e,"ClosestRaycaster",(function(){return N})),o.d(e,"AllHitsRaycaster",(function(){return Q})),o.d(e,"Types",(function(){return F})),o.d(e,"Clock",(function(){return q})),o.d(e,"AmmoPhysics",(function(){return X}));o(12),o(13);var s=o(1),i=o.n(s),n=o(10),r=o.n(n),a=o(4),l=o(2),c=o(7);var m=
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const o=this.factory.add.plane(t,e);return this.addExisting(o,t),o}addSphere(t={},e={}){const o=this.factory.add.sphere(t,e);return this.addExisting(o,t),o}addBox(t={},e={}){const o=this.factory.add.box(t,e);return this.addExisting(o,t),o}addGround(t,e={}){const o=this.factory.add.ground(t,e),s=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(o,s),o}addCylinder(t={},e={}){const o=this.factory.add.cylinder(t,e);return this.addExisting(o,t),o}addCone(t={},e={}){const o=this.factory.add.cone(t,e);return this.addExisting(o,t),o}addTorus(t={},e={}){const o=this.factory.add.torus(t,e);return this.addExisting(o,t),o}addExtrude(t,e={}){const o=this.factory.add.extrude(t,e);return o.translateX(1),this.addExisting(o),o}};
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class h{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e,o)=>this.lock(t,e,o),fixed:(t,e,o)=>this.fixed(t,e,o),pointToPoint:(t,e,o,s)=>this.pointToPoint(t,e,o,s),hinge:(t,e,o,s)=>this.hinge(t,e,o,s),slider:(t,e,o={},s)=>this.slider(t,e,o,s),spring:(t,e,o={},s)=>this.spring(t,e,o,s),coneTwist:(t,e,o={frameA:{},frameB:{}},s)=>this.coneTwist(t,e,o,s),dof:(t,e,o,s)=>this.dof(t,e,o,s)}}getTransform(t,e,o={x:0,y:0,z:0},s=!1){o=Object.assign({x:0,y:0,z:0},o);const i=new Ammo.btTransform;if(i.setIdentity(),s){const s=(n=t.getWorldTransform().getOrigin(),r=e.getWorldTransform().getOrigin(),a=(n.x()-r.x())/2+o.x,l=(n.y()-r.y())/2+o.y,c=(n.z()-r.z())/2+o.z,new Ammo.btVector3(a,l,c)),i=new Ammo.btTransform;i.setIdentity(),i.setOrigin(s);const m=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return m.op_mul(i),{transformA:m,transformB:i}}i.setOrigin(new Ammo.btVector3(o.x,o.y,o.z));return{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(i),transformB:i};var n,r,a,l,c}lock(t,e,o=!0){const s={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:s,angularUpperLimit:s},o)}fixed(t,e,o=!0){const s=this.getTransform(t.ammo,e.ammo);s.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),s.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(t.ammo,e.ammo,s.transformA,s.transformB);return this.physicsWorld.addConstraint(i,o),i}pointToPoint(t,e,o={},s=!0){const{pivotA:i,pivotB:n}=o,r=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),a=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),l=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,r,a);return this.physicsWorld.addConstraint(l,s),l}hinge(t,e,o={},s=!0){const{pivotA:i,pivotB:n,axisA:r,axisB:a}=o,l=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),c=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),m=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),h=new Ammo.btVector3((null==a?void 0:a.x)||0,(null==a?void 0:a.y)||0,(null==a?void 0:a.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,l,c,m,h,!0);return this.physicsWorld.addConstraint(d,s),d}slider(t,e,o={},s=!0){const i=this.getTransform(t.ammo,e.ammo),{frameA:n={},frameB:r={},linearLowerLimit:a=0,linearUpperLimit:l=0,angularLowerLimit:c=0,angularUpperLimit:m=0}=o,h=i.transformA.getRotation();h.setEulerZYX(n.x||0,n.y||0,n.z||0),i.transformA.setRotation(h);const d=i.transformB.getRotation();d.setEulerZYX(r.x||0,r.y||0,r.z||0),i.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,i.transformA,i.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(l),u.setLowerAngLimit(c),u.setUpperAngLimit(m),this.physicsWorld.addConstraint(u,s),u}spring(t,e,o={},s=!0){const{stiffness:i=50,damping:n=.01,angularLock:r=!1,linearLowerLimit:a={},linearUpperLimit:l={},angularLowerLimit:c={},angularUpperLimit:m={},offset:h={},center:d=!1,enableSpring:u=!0}=o,p=Object.assign({x:0,y:0,z:0},h),y=this.getTransform(t.ammo,e.ammo,p,d),f=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),f.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(l.x||0,l.y||0,l.z||0),f.setLinearUpperLimit(this.tmpBtVector3),r?(this.tmpBtVector3.setValue(0,0,0),f.setAngularLowerLimit(this.tmpBtVector3),f.setAngularUpperLimit(this.tmpBtVector3)):(console.log(c,m),f.setAngularLowerLimit(this.toAmmoV3(c,-Math.PI)),f.setAngularUpperLimit(this.toAmmoV3(m,Math.PI)));for(let t=0;t<3;t++)f.enableSpring(t,u),f.setStiffness(t,i),f.setDamping(t,n);return this.physicsWorld.addConstraint(f,s),f}coneTwist(t,e,o,s=!0){const{frameA:i,frameB:n}=o,r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0);this.getTransform(t.ammo,e.ammo);const l=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,r,a);return l.setAngularOnly(!0),this.physicsWorld.addConstraint(l,s),l}dof(t,e,o={},s=!0){const{offset:i,center:n=!1}=o,r=Object.assign({x:0,y:0,z:0},i),a=this.getTransform(t.ammo,e.ammo,r,n),l=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:c,linearUpperLimit:m,angularLowerLimit:h,angularUpperLimit:d}=o,u=this.toAmmoV3(c),p=this.toAmmoV3(m),y=this.toAmmoV3(h,-Math.PI),f=this.toAmmoV3(d,Math.PI);return l.setLinearLowerLimit(u),l.setLinearUpperLimit(p),l.setAngularLowerLimit(y),l.setAngularUpperLimit(f),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(f),this.physicsWorld.addConstraint(l,s),l}}var d=o(3),u=o(0);const p="hull",y="hacd",f="vhacd",b="mesh",g="all",v="manual",w=function(){const t=new u.Vector3,e=new u.Vector3,o=new u.Matrix4;return function(s,i,n,r={}){if(r.type=p,_(r),r.fit===v)return console.warn("cannot use fit: manual with type: hull"),null;const a=B(s,i),l=new Ammo.btVector3,c=new Ammo.btConvexHullShape;c.setMargin(r.margin),e.addVectors(a.max,a.min).multiplyScalar(.5);let m=0;for(let t=0;t<s.length;t++)m+=s[t].length/3;const h=r.hullMaxVertices||1e5;m>h&&console.warn(`too many vertices for hull shape; sampling ~${h} from ~${m} vertices`);const d=Math.min(1,h/m);for(let n=0;n<s.length;n++){const r=s[n];o.fromArray(i[n]);for(let i=0;i<r.length;i+=3){const a=n===s.length-1&&i===r.length-3;(Math.random()<=d||a)&&(t.set(r[i],r[i+1],r[i+2]).applyMatrix4(o).sub(e),l.setValue(t.x,t.y,t.z),c.addPoint(l,a))}}let u=c;if(c.getNumVertices()>=100){const t=new Ammo.btShapeHull(c);t.buildHull(r.margin),Ammo.destroy(c),u=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(l),C(u,r,P(n,r)),u}}(),x=function(){const t=new u.Vector3,e=new u.Vector3,o=new u.Matrix4;return function(s,i,n,r,a={}){if(a.type=y,_(a),a.fit===v)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=B(s,i),c=P(r,a);let m=0,h=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<s.length;t++)m+=s[t].length/3,n&&n[t]?h+=n[t].length/3:h+=s[t].length/9;const d=new Ammo.HACD;a.hasOwnProperty("compacityWeight")&&d.SetCompacityWeight(a.compacityWeight),a.hasOwnProperty("volumeWeight")&&d.SetVolumeWeight(a.volumeWeight),a.hasOwnProperty("nClusters")&&d.SetNClusters(a.nClusters),a.hasOwnProperty("nVerticesPerCH")&&d.SetNVerticesPerCH(a.nVerticesPerCH),a.hasOwnProperty("concavity")&&d.SetConcavity(a.concavity);const u=Ammo._malloc(3*m*8),p=Ammo._malloc(3*h*4);d.SetPoints(u),d.SetTriangles(p),d.SetNPoints(m),d.SetNTriangles(h);let f=u/8,b=p/4;for(let r=0;r<s.length;r++){const a=s[r];o.fromArray(i[r]);for(let s=0;s<a.length;s+=3)t.set(a[s+0],a[s+1],a[s+2]).applyMatrix4(o).sub(e),Ammo.HEAPF64[f+0]=t.x,Ammo.HEAPF64[f+1]=t.y,Ammo.HEAPF64[f+2]=t.z,f+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[b]=t[e],b++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[b]=t,b++}d.Compute(),Ammo._free(u),Ammo._free(p);const g=d.GetNClusters(),w=[];for(let t=0;t<g;t++){const e=new Ammo.btConvexHullShape;e.setMargin(a.margin);const o=d.GetNPointsCH(t),s=d.GetNTrianglesCH(t),i=Ammo._malloc(3*o*8),n=Ammo._malloc(3*s*4);d.GetCH(t,i,n);const r=i/8;for(let t=0;t<o;t++){const s=new Ammo.btVector3,i=Ammo.HEAPF64[r+3*t+0],n=Ammo.HEAPF64[r+3*t+1],a=Ammo.HEAPF64[r+3*t+2];s.setValue(i,n,a),e.addPoint(s,t===o-1),Ammo.destroy(s)}C(e,a,c),w.push(e)}return w}}(),A=function(){const t=new u.Vector3,e=new u.Vector3,o=new u.Matrix4;return function(s,i,n,r,a={}){if(a.type=f,_(a),a.fit===v)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=B(s,i),c=P(r,a);let m=0,h=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<s.length;t++)m+=s[t].length/3,n&&n[t]?h+=n[t].length/3:h+=s[t].length/9;const d=new Ammo.VHACD,u=new Ammo.Parameters;a.hasOwnProperty("resolution")&&u.set_m_resolution(a.resolution),a.hasOwnProperty("depth")&&u.set_m_depth(a.depth),a.hasOwnProperty("concavity")&&u.set_m_concavity(a.concavity),a.hasOwnProperty("planeDownsampling")&&u.set_m_planeDownsampling(a.planeDownsampling),a.hasOwnProperty("convexhullDownsampling")&&u.set_m_convexhullDownsampling(a.convexhullDownsampling),a.hasOwnProperty("alpha")&&u.set_m_alpha(a.alpha),a.hasOwnProperty("beta")&&u.set_m_beta(a.beta),a.hasOwnProperty("gamma")&&u.set_m_gamma(a.gamma),a.hasOwnProperty("pca")&&u.set_m_pca(a.pca),a.hasOwnProperty("mode")&&u.set_m_mode(a.mode),a.hasOwnProperty("maxNumVerticesPerCH")&&u.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),a.hasOwnProperty("minVolumePerCH")&&u.set_m_minVolumePerCH(a.minVolumePerCH),a.hasOwnProperty("convexhullApproximation")&&u.set_m_convexhullApproximation(a.convexhullApproximation),a.hasOwnProperty("oclAcceleration")&&u.set_m_oclAcceleration(a.oclAcceleration);const p=Ammo._malloc(3*m*8+3),y=Ammo._malloc(3*h*4);let b=p/8,g=y/4;for(let r=0;r<s.length;r++){const a=s[r];o.fromArray(i[r]);for(let s=0;s<a.length;s+=3)t.set(a[s+0],a[s+1],a[s+2]).applyMatrix4(o).sub(e),Ammo.HEAPF64[b+0]=t.x,Ammo.HEAPF64[b+1]=t.y,Ammo.HEAPF64[b+2]=t.z,b+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[g]=t[e],g++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[g]=t,g++}d.Compute(p,3,m,y,3,h,u),Ammo._free(p),Ammo._free(y);const w=d.GetNConvexHulls(),x=[],A=new Ammo.ConvexHull;for(let t=0;t<w;t++){d.GetConvexHull(t,A);const e=A.get_m_nPoints(),o=(A.get_m_points(),new Ammo.btConvexHullShape);o.setMargin(a.margin);for(let t=0;t<e;t++){const s=new Ammo.btVector3,i=A.get_m_points(3*t+0),n=A.get_m_points(3*t+1),r=A.get_m_points(3*t+2);s.setValue(i,n,r),o.addPoint(s,t===e-1),Ammo.destroy(s)}C(o,a,c),x.push(o)}return Ammo.destroy(A),Ammo.destroy(d),x}}(),V=function(){const t=new u.Vector3,e=new u.Vector3,o=new u.Vector3,s=new u.Matrix4;return function(i,n,r,a,l={}){if(l.type=b,_(l),l.fit===v)return console.warn("cannot use fit: manual with type: mesh"),null;const c=P(a,l),m=new Ammo.btVector3,h=new Ammo.btVector3,d=new Ammo.btVector3,u=new Ammo.btTriangleMesh(!0,!1);for(let a=0;a<i.length;a++){const l=i[a],c=r[a]?r[a]:null;if(s.fromArray(n[a]),c)for(let i=0;i<c.length;i+=3){const n=3*c[i],r=3*c[i+1],a=3*c[i+2];t.set(l[n],l[n+1],l[n+2]).applyMatrix4(s),e.set(l[r],l[r+1],l[r+2]).applyMatrix4(s),o.set(l[a],l[a+1],l[a+2]).applyMatrix4(s),m.setValue(t.x,t.y,t.z),h.setValue(e.x,e.y,e.z),d.setValue(o.x,o.y,o.z),u.addTriangle(m,h,d,!1)}else for(let i=0;i<l.length;i+=9)t.set(l[i+0],l[i+1],l[i+2]).applyMatrix4(s),e.set(l[i+3],l[i+4],l[i+5]).applyMatrix4(s),o.set(l[i+6],l[i+7],l[i+8]).applyMatrix4(s),m.setValue(t.x,t.y,t.z),h.setValue(e.x,e.y,e.z),d.setValue(o.x,o.y,o.z),u.addTriangle(m,h,d,!1)}const p=new Ammo.btVector3(c.x,c.y,c.z);let y;return u.setScaling(p),Ammo.destroy(p),y=l.concave?new Ammo.btBvhTriangleMeshShape(u,!0,!0):new Ammo.btConvexTriangleMeshShape(u,!0),y.resources=[u],Ammo.destroy(m),Ammo.destroy(h),Ammo.destroy(d),C(y,l),y}}();function _(t){t.type=t.type||p,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const C=function(t,e,o){},M=function(){const t=new u.Matrix4;return function(e,o,s){+u.REVISION>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld);(new u.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse(i=>{const n=new u.Matrix4;i.isMesh&&(o.includeInvisible||i.el&&i.el.object3D.visible||i.visible)&&(i===e?n.identity():(i.updateWorldMatrix(!0),n.multiplyMatrices(t,i.matrixWorld)),s(i.geometry.isBufferGeometry?i.geometry.attributes.position.array:i.geometry.vertices,n.elements,i.geometry.index?i.geometry.index.array:null))})}}(),P=function(){const t=new u.Matrix4;return function(e,o={}){const s=new u.Vector3(1,1,1);return o.fit===g&&(t.fromArray(e),s.setFromMatrixScale(t)),s}}(),B=(function(){const t=new u.Vector3}(),function(t,e){const o=new u.Box3;let s=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,l=-1/0;return o.min.set(0,0,0),o.max.set(0,0,0),O(t,e,t=>{t.x<s&&(s=t.x),t.y<i&&(i=t.y),t.z<n&&(n=t.z),t.x>r&&(r=t.x),t.y>a&&(a=t.y),t.z>l&&(l=t.z)}),o.min.set(s,i,n),o.max.set(r,a,l),o}),O=function(){const t=new u.Vector3,e=new u.Matrix4;return function(o,s,i){for(let n=0;n<o.length;n++){e.fromArray(s[n]);for(let s=0;s<o[n].length;s+=3)t.set(o[n][s],o[n][s+1],o[n][s+2]).applyMatrix4(e),i(t)}}}();var S=o(11),T=o.n(S);
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class j extends d.EventEmitter{addCollider(t,e,o){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",s=>{var i,n;const{bodies:r,event:a}=s;(null===(i=r[0])||void 0===i?void 0:i.name)&&(null===(n=r[1])||void 0===n?void 0:n.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(r[0].name===t.name&&r[1].name===e.name||r[1].name===t.name&&r[0].name===e.name)&&o(a)}))}}
/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */const E=1,k=32768;var D=class{constructor(t,e,o={}){this.scene=t,this.world=e,this.options=o,this.debugDrawMode=o.debugDrawMode||E;const s=this.debugDrawMode&k||!1,i=o.maxBufferSize||1e6;this.geometry=new u.BufferGeometry;const n=new Float32Array(3*i),r=new Float32Array(3*i);this.geometry.setAttribute("position",new u.BufferAttribute(n,3).setUsage(u.StaticDrawUsage)),this.geometry.setAttribute("color",new u.BufferAttribute(r,3).setUsage(u.StaticDrawUsage)),this.index=0;const a=new u.LineBasicMaterial({vertexColors:!0,depthTest:!s});this.mesh=new u.LineSegments(this.geometry,a),s&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,o){const s=Ammo.HEAPF32,i=s[(o+0)/4],n=s[(o+4)/4],r=s[(o+8)/4],a=s[(t+0)/4],l=s[(t+4)/4],c=s[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,l,c),this.geometry.attributes.color.setXYZ(this.index++,i,n,r);const m=s[(e+0)/4],h=s[(e+4)/4],d=s[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,m,h,d),this.geometry.attributes.color.setXYZ(this.index++,i,n,r)}drawContactPoint(t,e,o,s,i){const n=Ammo.HEAPF32,r=n[(i+0)/4],a=n[(i+4)/4],l=n[(i+8)/4],c=n[(t+0)/4],m=n[(t+4)/4],h=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,c,m,h),this.geometry.attributes.color.setXYZ(this.index++,r,a,l);const d=n[(e+0)/4]*o,u=n[(e+4)/4]*o,p=n[(e+8)/4]*o;this.geometry.attributes.position.setXYZ(this.index,c+d,m+u,h+p),this.geometry.attributes.color.setXYZ(this.index++,r,a,l)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}};const z=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new u.Line3,this.tempPlane1=new u.Plane,this.tempPlane2=new u.Plane,this.tempPlane_Cut=new u.Plane,this.tempCM1=new u.Vector3,this.tempCM2=new u.Vector3,this.tempVector3=new u.Vector3,this.tempVector3_2=new u.Vector3,this.tempVector3_3=new u.Vector3,this.tempVector3_P0=new u.Vector3,this.tempVector3_P1=new u.Vector3,this.tempVector3_P2=new u.Vector3,this.tempVector3_N0=new u.Vector3,this.tempVector3_N1=new u.Vector3,this.tempVector3_AB=new u.Vector3,this.tempVector3_CB=new u.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var o=0;o<900;o++)this.segments[o]=!1};var L;z.prototype={constructor:z,prepareBreakableObject:function(t,e,o,s,i){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var n=t.userData.ammoPhysicsData;n.mass=e,n.velocity=o.clone(),n.angularVelocity=s.clone(),n.breakable=i},subdivideByImpact:function(t,e,o,s,i){var n=[],r=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,o),r.setFromCoplanarPoints(e,t.position,this.tempVector3);var l=i+s,c=this;return function i(m,h,d,u){if(Math.random()<.05*u||u>l)n.push(m);else{var p=Math.PI;0===u?(a.normal.copy(r.normal),a.constant=r.constant):u<=s?(p=(d-h)*(.2+.6*Math.random())+h,c.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(o,p).add(e),a.setFromCoplanarPoints(e,c.tempVector3,c.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,c.tempVector3_2.copy(e).sub(m.position).applyAxisAngle(o,p).add(m.position),c.tempVector3_3.copy(o).add(m.position),a.setFromCoplanarPoints(m.position,c.tempVector3_3,c.tempVector3_2)),c.cutByPlane(m,a,c.tempResultObjects);var y=c.tempResultObjects.object1,f=c.tempResultObjects.object2;y&&i(y,h,p,u+1),f&&i(f,p,d,u+1)}}(t,0,2*Math.PI,0),n},cutByPlane:function(t,e,o){var s=t.geometry,n=s.attributes.position.array,r=s.attributes.normal.array,a=n.length/3,l=a/3,c=s.getIndex();function m(t,e){var o=3*t+e;return c?c[o]:o}c&&(l=(c=c.array).length/3);for(var h=[],d=[],p=this.smallDelta,y=a*a,f=0;f<y;f++)this.segments[f]=!1;var b=this.tempVector3_P0,g=this.tempVector3_P1,v=this.tempVector3_N0,w=this.tempVector3_N1;for(f=0;f<l-1;f++){var x=m(f,0),A=m(f,1),V=m(f,2);v.set(r[x],r[x]+1,r[x]+2);for(var _=f+1;_<l;_++){var C=m(_,0),M=m(_,1),P=m(_,2);w.set(r[C],r[C]+1,r[C]+2),1-v.dot(w)<p&&(x===C||x===M||x===P?A===C||A===M||A===P?(this.segments[x*a+A]=!0,this.segments[A*a+x]=!0):(this.segments[V*a+x]=!0,this.segments[x*a+V]=!0):A!==C&&A!==M&&A!==P||(this.segments[V*a+A]=!0,this.segments[A*a+V]=!0))}}var B=this.tempPlane_Cut;t.updateMatrix(),z.transformPlaneToLocalSpace(e,t.matrix,B);for(f=0;f<l;f++)for(var O=m(f,0),S=m(f,1),T=m(f,2),j=0;j<3;j++){var E=0===j?O:1===j?S:T,k=0===j?S:1===j?T:O;if(!this.segments[E*a+k]){this.segments[E*a+k]=!0,this.segments[k*a+E]=!0,b.set(n[3*E],n[3*E+1],n[3*E+2]),g.set(n[3*k],n[3*k+1],n[3*k+2]);var D=0;(L=B.distanceToPoint(b))>p?(D=2,d.push(b.clone())):L<-p?(D=1,h.push(b.clone())):(D=3,h.push(b.clone()),d.push(b.clone()));var L,R=0;if((L=B.distanceToPoint(g))>p?(R=2,d.push(g.clone())):L<-p?(R=1,h.push(g.clone())):(R=3,h.push(g.clone()),d.push(g.clone())),1===D&&2===R||2===D&&1===R){this.tempLine1.start.copy(b),this.tempLine1.end.copy(g);var W=new u.Vector3;if(void 0===(W=B.intersectLine(this.tempLine1,W)))return console.error("Internal error: segment does not intersect plane."),o.segmentedObject1=null,o.segmentedObject2=null,0;h.push(W),d.push(W.clone())}}}var H=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var F=0,G=h.length;if(G>0){for(f=0;f<G;f++)this.tempCM1.add(h[f]);this.tempCM1.divideScalar(G);for(f=0;f<G;f++){(N=h[f]).sub(this.tempCM1),F=Math.max(F,N.x,N.y,N.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var I=0,U=d.length;if(U>0){for(f=0;f<U;f++)this.tempCM2.add(d[f]);this.tempCM2.divideScalar(U);for(f=0;f<U;f++){var N;(N=d[f]).sub(this.tempCM2),I=Math.max(I,N.x,N.y,N.z)}this.tempCM2.add(t.position)}var Q=null,q=null,X=0;if(G>4)try{(Q=new u.Mesh(new u.ConvexBufferGeometry(h),t.material)).position.copy(this.tempCM1),Q.quaternion.copy(t.quaternion),Q.userData=t.userData,this.prepareBreakableObject(Q,H,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*F>this.minSizeForBreak),X++}catch(t){i()("Error in ConvexObjectBreaker.ts"),i()(t)}if(U>4)try{(q=new u.Mesh(new u.ConvexBufferGeometry(d),t.material)).position.copy(this.tempCM2),q.quaternion.copy(t.quaternion),q.userData=t.userData,this.prepareBreakableObject(q,H,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*I>this.minSizeForBreak),X++}catch(t){i()("Error in ConvexObjectBreaker.ts"),i()(t)}return o.object1=Q,o.object2=q,X}},z.transformFreeVector=function(t,e){var o=t.x,s=t.y,i=t.z,n=e.elements;return t.x=n[0]*o+n[4]*s+n[8]*i,t.y=n[1]*o+n[5]*s+n[9]*i,t.z=n[2]*o+n[6]*s+n[10]*i,t},z.transformFreeVectorInverse=function(t,e){var o=t.x,s=t.y,i=t.z,n=e.elements;return t.x=n[0]*o+n[1]*s+n[2]*i,t.y=n[4]*o+n[5]*s+n[6]*i,t.z=n[8]*o+n[9]*s+n[10]*i,t},z.transformTiedVectorInverse=function(t,e){var o=t.x,s=t.y,i=t.z,n=e.elements;return t.x=n[0]*o+n[1]*s+n[2]*i-n[12],t.y=n[4]*o+n[5]*s+n[6]*i-n[13],t.z=n[8]*o+n[9]*s+n[10]*i-n[14],t},z.transformPlaneToLocalSpace=(L=new u.Vector3,function(t,e,o){o.normal.copy(t.normal),o.constant=t.constant;var s=z.transformTiedVectorInverse(t.coplanarPoint(L),e);z.transformFreeVectorInverse(o.normal,e),o.constant=-s.dot(o.normal)});var R=o(8),W=o(5),H=o.n(W),F=o(9),G=o(6),I=o.n(G);
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class U{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,o=0){this._btRayFrom.setValue(t,e,o)}setRayToWorld(t=0,e=0,o=0){this._btRayTo.setValue(t,e,o)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class N{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class Q{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}I()(N,[U,
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */]),I()(Q,[U,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let o=t.size()-1;o>=0;o--){const s=t.at(o);e.push({x:s.x(),y:s.y(),z:s.z()})}return e}getHitPointWorld(){return console.warn("[enable3d] Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let o=t.size()-1;o>=0;o--){const s=t.at(o);e.push({x:s.x(),y:s.y(),z:s.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let o=e.size()-1;o>=0;o--){const s=Ammo.castObject(e.at(o),Ammo.btRigidBody);t.push(s.threeObject)}return t}}]);class q{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */class X extends d.EventEmitter{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new u.Euler,this.tmpQuaternion=new u.Quaternion,this.tmpVector3=new u.Vector3,this.tmpVector3a=new u.Vector3,this.tmpMatrix4=new u.Matrix4,this.tmpMatrix4a=new u.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new u.Vector3,this.impactPoint=new u.Vector3,this.impactNormal=new u.Vector3,"headless"!==t&&(this.defaultMaterial=new H.a),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var e;const o=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==o?void 0:o.ammo))return;const s=o.ammo.name;let i=o.ammo.threeObject;if(s&&i&&(null===(e=null==i?void 0:i.body)||void 0===e?void 0:e.ammo)){i.body.isSoftBody?this.physicsWorld.removeSoftBody(i.body.ammo):this.physicsWorld.removeRigidBody(i.body.ammo),i.body.destructor(),i.body=void 0,i.hasBody=!1,delete o.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===s&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&i&&(i=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new z,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new j,this.factory=new T.a(this.scene),this.shapes=new m(this.factory,(t,e)=>this.addExisting(t,e)),this.constraints=new h(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new D(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let o;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),s=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver;o=new Ammo.btDiscreteDynamicsWorld(e,s,i,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),s=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver,n=new Ammo.btDefaultSoftBodySolver;o=new Ammo.btSoftRigidDynamicsWorld(e,s,i,t,n)}return o.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),o}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=this.defaultMaterial.get(),t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,this.scene.add(t),this.addExisting(t),t.body.breakable=!1,setTimeout(()=>{t.body.breakable=!0},2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t],o=e.body.ammo.getMotionState();if(o)if(o.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),o.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){let t=this.worldTransform.getOrigin(),o=this.worldTransform.getRotation(),s=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+s.x,t.y()+s.y,t.z()+s.z),this.tmpQuaternion.set(o.x(),o.y(),o.z(),o.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?+u.REVISION>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){var t,e;const o=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const s=this.physicsWorld.getDispatcher(),i=s.getNumManifolds();for(let n=0;n<i;n++){let i=s.getManifoldByIndexInternal(n),r=i.getNumContacts();const a=Ammo.castObject(i.getBody0(),Ammo.btRigidBody),l=Ammo.castObject(i.getBody1(),Ammo.btRigidBody);let c=a.threeObject,m=l.threeObject;if(!c||!m)continue;if(""===a.name&&""===l.name)continue;const h=null===(t=c.body)||void 0===t?void 0:t.checkCollisions,d=null===(e=m.body)||void 0===e?void 0:e.checkCollisions,u=c.body.breakable,p=m.body.breakable,y=u||p;if(!(h||d)&&!y)continue;let f=!1,b=0,g="start";for(let t=0;t<r;t++){const e=i.getContactPoint(t);if(e.getDistance()<=0){f=!0;const t=e.getAppliedImpulse(),s=e.get_m_positionWorldOnB(),i=e.get_m_normalWorldOnB();if(h||d){const t=[c.name,m.name].sort(),e=`${t[0]}__${t[1]}`;this.earlierDetectedCollisions.find(t=>t.combinedName===e)&&(g="collision"),o.find(t=>t.combinedName===e)||(o.push({combinedName:e,collision:!0}),this.collisionEvents.emit("collision",{bodies:[c,m],event:g}))}t>=b&&(b=t,(u||p)&&(this.impactPoint.set(s.x(),s.y(),s.z()),this.impactNormal.set(i.x(),i.y(),i.z())));break}}if(!f)continue;if(!y)continue;const v=5,w=2;if(this.emptyV3.set(0,0,0),c.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},m.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:p,physicsBody:l},void 0===c.fragmentDepth&&(c.fragmentDepth=0),void 0===m.fragmentDepth&&(m.fragmentDepth=0),u&&b>v&&c.fragmentDepth<w){const t=this.convexBreaker.subdivideByImpact(c,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let o=0;o<e;o++){const e=a.getLinearVelocity(),s=a.getAngularVelocity(),i=t[o];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(s.x(),s.y(),s.z()),this.createDebrisFromBreakableObject(i,c)}this.objectsToRemove[this.numObjectsToRemove++]=c}if(p&&b>v&&m.fragmentDepth<w){const t=this.convexBreaker.subdivideByImpact(m,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let o=0;o<e;o++){const e=l.getLinearVelocity(),s=l.getAngularVelocity(),i=t[o];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(s.x(),s.y(),s.z()),this.createDebrisFromBreakableObject(i,m)}this.objectsToRemove[this.numObjectsToRemove++]=m}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(t=>{const{combinedName:e}=t;if(!o.find(t=>t.combinedName===e)){const t=e.split("__"),o=this.rigidBodies.find(e=>e.name===t[0]),s=this.rigidBodies.find(e=>e.name===t[1]),i="end";o&&s&&this.collisionEvents.emit("collision",{bodies:[o,s],event:i})}}),this.earlierDetectedCollisions=[...o]}setGravity(t=0,e=-9.8,o=0){this.tmpBtVector3.setValue(t,e,o),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then(()=>{this.setup()}):this.setup():i()("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,o)=>this.collisionEvents.addCollider(t,e,o),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new N(this):new Q(this)}}prepareThreeObjectForCollisionShape(t,e={}){var o,s;const{autoCenter:n=!1}=e,r={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let a="unknown";const l=(null===(o=t.geometry)||void 0===o?void 0:o.type)||"unknown";/box/i.test(l)?a="box":/cone/i.test(l)?a="cone":/cylinder/i.test(l)?a="cylinder":/extrude/i.test(l)?a="extrude":/plane/i.test(l)?a="plane":/sphere/i.test(l)?a="sphere":/torus/i.test(l)&&(a="torus");let c=Object.assign(Object.assign({},r),null===(s=null==t?void 0:t.geometry)||void 0===s?void 0:s.parameters);return e.shape?(c=Object.assign(Object.assign({},r),e),a=e.shape):t.shape&&(a=t.shape),Object.keys(c).forEach(t=>{void 0===c[t]&&r[t]&&(c[t]=r[t])}),n&&t.geometry.center(),"cylinder"===a&&(c.radius=e.radius||c.radiusTop),"extrude"===a&&(a="hacd"),"mesh"!==a&&"convex"!==a||(a="convexMesh"),"concave"===a&&(a="concaveMesh"),"unknown"===a&&(i()(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`),a="box"),{shape:a,params:c,object:t}}createCollisionShape(t,e,o){const s=(null==o?void 0:o.quaternion)?null==o?void 0:o.quaternion:new u.Quaternion(0,0,0,1),{axis:i="y"}=e,n=new Ammo.btVector3,r=null==o?void 0:o.geometry;o&&(null==r?void 0:r.isGeometry)&&(o.geometry=(new u.BufferGeometry).fromGeometry(r));let a,l={};switch(this.complexShapes.indexOf(t)>0&&(l=(t=>{const e=(new u.Matrix4).elements,o=[],s=[],i=[];return M(t,{},(t,e,n)=>{o.push(t),s.push(e),i.push(n)}),{vertices:o,matrices:s,indexes:i,matrixWorld:e}})(o)),t){case"box":n.setValue(e.width/2,e.height/2,e.depth/2),a=new Ammo.btBoxShape(n);break;case"sphere":a=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(i){case"y":n.setValue(e.radius,e.height/2,e.radius),a=new Ammo.btCylinderShape(n);break;case"x":n.setValue(e.height/2,e.radius,e.radius),a=new Ammo.btCylinderShapeX(n);break;case"z":n.setValue(e.radius,e.radius,e.height/2),a=new Ammo.btCylinderShapeZ(n)}break;case"cone":switch(i){case"y":a=new Ammo.btConeShape(e.radius,e.height);break;case"x":a=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":a=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(i){case"y":a=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":a=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":a=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":a=((t,e)=>{const{radius:o=1,tube:s=.4,tubularSegments:i=8}=t,n=Math.PI,r=i,a=Math.sqrt(2*s*s-2*s*s*Math.cos(2*n/r)),l=new Ammo.btVector3(s,n/r+.5*a,s),c=new Ammo.btCylinderShape(l);c.setMargin(.05);const m=new Ammo.btCompoundShape,h=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,o,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<r;t++){const e=2*t*n/r,o=d.rotate(h,e),s=new Ammo.btTransform;u.setRotation(h,e+Math.PI/2),s.setIdentity(),s.setOrigin(o),s.setRotation(u),m.addChildShape(s,c)}return m})(e,s);break;case"plane":a=V(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"hull":a=w(l.vertices,l.matrices,l.matrixWorld,e);break;case"hacd":a=x(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"vhacd":a=A(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"convexMesh":a=V(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"concaveMesh":a=V(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!0}))}Ammo.destroy(n);const{x:c,y:m,z:h}=e;return(c||m||h)&&(a.offset={x:c||0,y:m||0,z:h||0}),Array.isArray(a)&&(a=this.mergeCollisionShapesToCompoundShape(a)),a}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach(t=>{const{offset:o}=t,s=new Ammo.btTransform;s.setIdentity(),o&&s.getOrigin().setValue(o.x||0,o.y||0,o.z||0),e.addChildShape(s,t)}),e}addExisting(t,e={}){const{hasBody:o}=t;if(o)return void console.warn(`[Enable3d]: Object "${t.name}" already has a physical body!`);const s=new u.Vector3,i=new u.Quaternion,n=new u.Vector3;t.getWorldPosition(s),t.getWorldQuaternion(i),t.getWorldScale(n);const r="1"===(e.collisionFlags||0).toString(2).slice(-1),a="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:l="unknown",compound:c=[],mass:m=(r||a?0:1),collisionFlags:h=0,collisionGroup:d=1,collisionMask:p=-1,offset:y,breakable:f=!1,addChildren:b=!0,margin:g=.01,ignoreScale:v=!1}=e;if(v&&n.set(1,1,1),c.length>=1){const e=c.map(t=>this.createCollisionShape(t.shape,t)),o=this.mergeCollisionShapesToCompoundShape(e),r=this.finishCollisionShape(o,s,i,n,g),l=this.collisionShapeToRigidBody(o,r,m,a);return this.addRigidBodyToWorld(t,l,h,d,p,f,y),void(t.body.ignoreScale=v)}const w=[];if("unknown"!==l||t.isMesh){const o=this.prepareThreeObjectForCollisionShape(t,e),s=this.createCollisionShape(o.shape,o.params,o.object);w.push(s)}if("unknown"===l&&b&&t.children.length>=1&&t.children.forEach(t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),o=this.createCollisionShape(e.shape,e.params,e.object);o.offset=t.position.clone(),w.push(o)}}),0===w.length){const o=this.prepareThreeObjectForCollisionShape(t,e),s=this.createCollisionShape(o.shape,o.params,o.object);w.push(s)}const x=1===w.length?w[0]:this.mergeCollisionShapesToCompoundShape(w),A=this.finishCollisionShape(x,s,i,n,g),V=this.collisionShapeToRigidBody(x,A,m,a);this.addRigidBodyToWorld(t,V,h,d,p,f,y),t.body.ignoreScale=v}addRigidBodyToWorld(t,e,o,s,i,n,a){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,s,i);const l=Object.values(e)[0];e.name=t.name,t.body=new r.a(this,e),t.hasBody=!0,t.ptr=l,e.threeObject=t,n&&(t.body.breakable=!0),a&&(t.body.offset=Object.assign({x:0,y:0,z:0},a)),t.body.setCollisionFlags(o)}finishCollisionShape(t,e,o,s,i){t.setMargin(i);const n=new Ammo.btQuaternion(0,0,0,1);n.setValue(o.x,o.y,o.z,o.w);const r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue(e.x,e.y,e.z),r.setRotation(n),Ammo.destroy(n);const a=new Ammo.btVector3(s.x,s.y,s.z);return t.setLocalScaling(a),Ammo.destroy(a),r}collisionShapeToRigidBody(t,e,o,s){const i=new Ammo.btDefaultMotionState(e),n=new Ammo.btVector3(0,0,0);o>0&&t.calculateLocalInertia(o,n);const r=new Ammo.btRigidBodyConstructionInfo(o,i,t,n),a=new Ammo.btRigidBody(r);return(o>0||s)&&a.setActivationState(4),a}}}])}));
//# sourceMappingURL=enable3d.ammoPhysics.0.21.0.min.js.map